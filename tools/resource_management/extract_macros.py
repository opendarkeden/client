#!/usr/bin/env python3
"""
从 VS_UI_filepath.h 提取宏定义，生成 Properties 格式的 .inf 文件

用法:
    python3 extract_macros.py <header_file> <output_file> [--platform=PLATFORM]

示例:
    python3 extract_macros.py VS_UI/src/header/VS_UI_filepath.h DarkEden/Data/Info/VS_UI_filepath.inf
    python3 extract_macros.py VS_UI/src/header/VS_UI_filepath.h DarkEden/Data/Info/VS_UI_filepath.inf --platform=unix
"""

import re
import sys
import subprocess


def extract_macros_simple_fallback(header_file, inf_file):
    """
    简单的回退方法：直接解析 .h 文件，不处理宏展开
    只提取已经完全展开的字符串宏
    """
    extracted_count = 0

    try:
        with open(header_file, 'r', encoding='utf-8', errors='ignore') as f_in, \
             open(inf_file, 'w', encoding='utf-8') as f_out:

            # 写入文件头
            f_out.write("# Auto-generated from VS_UI_filepath.h\n")
            f_out.write("# DO NOT EDIT MANUALLY\n")
            f_out.write("# Generated by extract_macros.py (simple method)\n\n")

            # 收集所有宏定义
            macros = {}

            lines = f_in.readlines()

            # 首先收集所有基础路径宏（包括所有宏，用于展开）
            all_macros = {}
            for line in lines:
                line = line.strip()
                # 匹配任何 #define MACRO value
                match = re.match(r'#define\s+(\w+)\s+(.+)', line)
                if match:
                    name, value = match.groups()
                    value = value.strip()

                    # 去掉值两端的引号（存储时总是不带引号）
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]

                    # 清理路径：确保使用正斜杠
                    value = value.replace('\\', '/')

                    all_macros[name] = value

            # 然后收集资源宏并展开
            for line in lines:
                line = line.strip()
                if not line or line.startswith('//') or line.startswith('/*') or line.startswith('#/'):
                    continue

                # 匹配两种格式:
                # 1. #define MACRO "string"  （值用引号包围）
                # 2. #define MACRO OTHER_MACRO"string"  （宏连接）
                match = re.match(r'#define\s+(\w+)\s+(.+)', line)
                if match:
                    name, value = match.groups()
                    value = value.strip()

                    # 去掉值两端的引号（如果有）
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]

                    # 只保存我们关心的资源宏
                    if any(name.startswith(prefix) for prefix in ['SPK_', 'ISPK_', 'CFPK_', 'RPK_', 'FILE_INFO_', 'TXT_']):
                        # 展开宏引用（递归替换）
                        max_iterations = 10
                        for _ in range(max_iterations):
                            old_value = value
                            # 按照长度排序，先替换长的宏名（避免部分匹配）
                            for macro_name in sorted(all_macros.keys(), key=len, reverse=True):
                                if macro_name in value:
                                    # 只替换完整的单词边界
                                    pattern = r'\b' + re.escape(macro_name) + r'\b'
                                    if re.search(pattern, value):
                                        value = re.sub(pattern, all_macros[macro_name], value)

                            if value == old_value:
                                break  # 没有变化，完成展开

                        # 清理残留的引号
                        value = value.replace('"', '')

                        macros[name] = value

            # 输出资源宏（按名称排序）
            for name in sorted(macros.keys()):
                value = macros[name]
                f_out.write(f"{name} : {value}\n")
                extracted_count += 1

        print(f"✓ 已生成 {inf_file}")
        print(f"  提取了 {extracted_count} 个资源定义（简单方法）")
        return 0

    except FileNotFoundError as e:
        print(f"✗ 错误: 文件不存在: {e.filename}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ 错误: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


def extract_macros_with_preprocessor(header_file, inf_file, platform='unix'):
    """
    使用 gcc 预处理器提取宏定义（改进版）

    使用方法：创建一个临时 .c 文件包含头文件，然后使用 gcc -E 预处理
    这样可以正确处理条件编译和宏展开
    """
    import tempfile
    import os

    try:
        header_dir = os.path.dirname(header_file)
        if not header_dir:
            header_dir = '.'

        # 创建临时 C 文件来触发预处理
        temp_c = tempfile.mktemp(suffix='.c')

        with open(temp_c, 'w') as f:
            f.write(f'#include "{header_file}"\n')

        # 定义平台宏
        if platform == 'windows':
            platform_def = '-DPLATFORM_WINDOWS=1'
        else:
            platform_def = '-DPLATFORM_WINDOWS=0'

        # 使用 gcc -E 预处理（不使用 -dM，而是直接预处理）
        cmd = [
            'gcc', '-E',
            platform_def,
            '-I', header_dir,
            '-o', '-',  # 输出到 stdout
            temp_c
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)

        # 删除临时文件
        try:
            os.remove(temp_c)
        except:
            pass

        if result.returncode != 0:
            print(f"警告: gcc 预处理器失败，使用简单方法", file=sys.stderr)
            return None

        # 解析预处理后的输出
        # 我们需要扫描预处理后的代码，找到字符串常量的使用
        # 这是一个简化的方法 - 我们直接使用简单方法
        return None

    except Exception as e:
        print(f"警告: 预处理器方法失败 ({e})，使用简单方法", file=sys.stderr)
        return None


def extract_macros(header_file, inf_file, platform='unix'):
    """
    从 C 头文件提取资源宏定义，生成 .inf 文件
    使用简单的字符串提取方法
    """
    # 直接使用简单方法（因为 gcc -dM 在条件编译方面有问题）
    return extract_macros_simple_fallback(header_file, inf_file)


def print_usage(prog_name):
    """打印用法信息"""
    print(f"用法: {prog_name} <header_file> <output_file> [--platform=PLATFORM]")
    print()
    print("参数:")
    print("  header_file   VS_UI_filepath.h 文件路径")
    print("  output_file   输出的 .inf 文件路径")
    print("  --platform    目标平台 (windows|unix)，默认: unix")
    print()
    print("示例:")
    print(f"  {prog_name} VS_UI/src/header/VS_UI_filepath.h DarkEden/Data/Info/VS_UI_filepath.inf")
    print(f"  {prog_name} VS_UI/src/header/VS_UI_filepath.h DarkEden/Data/Info/VS_UI_filepath.inf --platform=windows")


if __name__ == '__main__':
    if len(sys.argv) < 3:
        print_usage(sys.argv[0])
        sys.exit(1)

    header_file = sys.argv[1]
    inf_file = sys.argv[2]
    platform = 'unix'

    if len(sys.argv) > 3:
        if sys.argv[3].startswith('--platform='):
            platform = sys.argv[3].split('=')[1]
            if platform not in ['windows', 'unix']:
                print(f"错误: 无效的平台 '{platform}'，必须是 'windows' 或 'unix'", file=sys.stderr)
                sys.exit(1)

    sys.exit(extract_macros(header_file, inf_file, platform))
